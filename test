import React, { useState, useEffect, useRef } from 'react';
import { Settings, Info, Maximize2, RotateCcw, Move } from 'lucide-react';

export default function ConeSectionTool() {
  const [height, setHeight] = useState(2); // Initial plane height (0 to 4)
  const [offsetX, setOffsetX] = useState(0); // Horizontal translation
  const [showPlane, setShowPlane] = useState(true);
  const [isThreeLoaded, setIsThreeLoaded] = useState(false);
  const containerRef = useRef<HTMLDivElement>(null);
  
  // Refs to store Three.js objects
  const sceneRef = useRef<any>(null);
  const cameraRef = useRef<any>(null);
  const rendererRef = useRef<any>(null);
  const planeMeshRef = useRef<any>(null);
  const intersectionRingRef = useRef<any>(null);
  const radiusLineRef = useRef<any>(null);
  
  // Camera control refs
  const isDragging = useRef(false);
  const isPanning = useRef(false); // New: Pan state
  const previousMousePosition = useRef({ x: 0, y: 0 });
  
  // Spherical Coordinates for Orbit
  const cameraAngle = useRef({ theta: Math.PI / 4, phi: Math.PI / 6 });
  const cameraRadius = useRef(10);
  const cameraTarget = useRef({ x: 0, y: 2.5, z: 0 }); // New: Target to look at (for panning)

  // Constants for Geometry
  const CONE_RADIUS = 2.5;
  const CONE_HEIGHT = 5;

  // 1. Load Three.js
  useEffect(() => {
    if (window.THREE) {
      setIsThreeLoaded(true);
      return;
    }

    const script = document.createElement('script');
    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js';
    script.async = true;
    script.onload = () => setIsThreeLoaded(true);
    document.body.appendChild(script);

    return () => {
      document.body.removeChild(script);
    };
  }, []);

  // 2. Initialize Scene
  useEffect(() => {
    if (!isThreeLoaded || !containerRef.current) return;

    const THREE = (window as any).THREE;

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff);
    sceneRef.current = scene;

    // Camera setup
    const camera = new THREE.PerspectiveCamera(
      45,
      containerRef.current.clientWidth / containerRef.current.clientHeight,
      0.1,
      100
    );
    cameraRef.current = camera;
    updateCameraPosition();

    // Renderer setup
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(containerRef.current.clientWidth, containerRef.current.clientHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    containerRef.current.appendChild(renderer.domElement);
    rendererRef.current = renderer;

    // --- Lighting ---
    const ambientLight = new THREE.AmbientLight(0x404040, 1.5);
    scene.add(ambientLight);

    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(5, 10, 7);
    dirLight.castShadow = true;
    scene.add(dirLight);

    // --- Grid & Axes ---
    const gridHelper = new THREE.GridHelper(20, 20, 0xcccccc, 0xe5e5e5);
    scene.add(gridHelper);
    
    // Axis Helper (X: Red, Y: Green, Z: Blue)
    const axesHelper = new THREE.AxesHelper(3);
    scene.add(axesHelper);

    // --- Objects ---

    // 1. The Cone (Transparent)
    const coneGeo = new THREE.ConeGeometry(CONE_RADIUS, CONE_HEIGHT, 64, 1, true); // open ended
    const coneMat = new THREE.MeshPhongMaterial({ 
      color: 0x2563eb, 
      transparent: true, 
      opacity: 0.3, 
      side: THREE.DoubleSide,
      shininess: 100
    });
    const cone = new THREE.Mesh(coneGeo, coneMat);
    cone.position.y = CONE_HEIGHT / 2;
    scene.add(cone);
    
    // Cone Base (Cap)
    const baseGeo = new THREE.CircleGeometry(CONE_RADIUS, 64);
    const baseMat = new THREE.MeshBasicMaterial({ color: 0x2563eb, transparent: true, opacity: 0.1, side: THREE.DoubleSide });
    const base = new THREE.Mesh(baseGeo, baseMat);
    base.rotation.x = -Math.PI / 2;
    scene.add(base);

    // 2. The Cutting Plane
    const planeGeo = new THREE.PlaneGeometry(8, 8);
    const planeMat = new THREE.MeshPhongMaterial({ 
      color: 0x64748b, 
      transparent: true, 
      opacity: 0.2, 
      side: THREE.DoubleSide,
      depthWrite: false
    });
    const plane = new THREE.Mesh(planeGeo, planeMat);
    plane.rotation.x = -Math.PI / 2;
    plane.visible = showPlane;
    scene.add(plane);
    planeMeshRef.current = plane;

    // 3. Intersection Ring
    const ringGeo = new THREE.TorusGeometry(1, 0.05, 32, 100);
    const ringMat = new THREE.MeshBasicMaterial({ color: 0xdc2626 }); // Red
    const ring = new THREE.Mesh(ringGeo, ringMat);
    ring.rotation.x = -Math.PI / 2;
    scene.add(ring);
    intersectionRingRef.current = ring;

    // 4. Radius Line
    const lineGeo = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(1, 0, 0)
    ]);
    const lineMat = new THREE.LineBasicMaterial({ color: 0xdc2626, linewidth: 2 });
    const rLine = new THREE.Line(lineGeo, lineMat);
    scene.add(rLine);
    radiusLineRef.current = rLine;

    // 5. Center Axis Line
    const axisGeo = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(0, 0, 0),
        new THREE.Vector3(0, CONE_HEIGHT, 0)
    ]);
    const axisMat = new THREE.LineDashedMaterial({ color: 0x000000, dashSize: 0.2, gapSize: 0.1, opacity: 0.5, transparent: true });
    const axisLine = new THREE.Line(axisGeo, axisMat);
    axisLine.computeLineDistances();
    scene.add(axisLine);

    // Animation Loop
    const animate = () => {
      if (!rendererRef.current) return;
      requestAnimationFrame(animate);
      rendererRef.current.render(scene, camera);
    };
    animate();

    const handleResize = () => {
      if (!containerRef.current || !cameraRef.current || !rendererRef.current) return;
      const width = containerRef.current.clientWidth;
      const height = containerRef.current.clientHeight;
      cameraRef.current.aspect = width / height;
      cameraRef.current.updateProjectionMatrix();
      rendererRef.current.setSize(width, height);
    };
    window.addEventListener('resize', handleResize);

    return () => {
      window.removeEventListener('resize', handleResize);
      if (containerRef.current && rendererRef.current) {
        containerRef.current.removeChild(rendererRef.current.domElement);
      }
      rendererRef.current.dispose();
    };
  }, [isThreeLoaded]);

  // 3. Update Scene based on State
  useEffect(() => {
    if (!isThreeLoaded || !planeMeshRef.current) return;

    const currentHeight = Math.max(0, Math.min(CONE_HEIGHT, height));
    
    // Update Plane Position (Height AND Horizontal Offset)
    planeMeshRef.current.position.y = currentHeight;
    planeMeshRef.current.position.x = offsetX; // Apply offset
    planeMeshRef.current.visible = showPlane;

    // Intersection Logic
    // Note: For a horizontal plane, horizontal offset does NOT change the intersection shape 
    // relative to the cone axis, as long as the plane still cuts the cone.
    // The red ring represents the intersection with the infinite mathematical plane y = h.
    const currentRadius = CONE_RADIUS * ((CONE_HEIGHT - currentHeight) / CONE_HEIGHT);

    if (intersectionRingRef.current) {
        intersectionRingRef.current.position.y = currentHeight;
        const scale = Math.max(0.001, currentRadius);
        intersectionRingRef.current.scale.set(scale, scale, 1); 
    }

    if (radiusLineRef.current) {
        radiusLineRef.current.position.y = currentHeight;
        const positions = radiusLineRef.current.geometry.attributes.position.array;
        positions[3] = currentRadius; 
        radiusLineRef.current.geometry.attributes.position.needsUpdate = true;
    }

  }, [height, offsetX, showPlane, isThreeLoaded]);

  // Helper: Update Camera Position
  const updateCameraPosition = () => {
    if (!cameraRef.current) return;
    const { theta, phi } = cameraAngle.current;
    const r = cameraRadius.current;
    const target = cameraTarget.current;
    
    const x = r * Math.sin(phi) * Math.sin(theta);
    const y = r * Math.cos(phi);
    const z = r * Math.sin(phi) * Math.cos(theta);

    cameraRef.current.position.set(x + target.x, y + target.y, z + target.z);
    cameraRef.current.lookAt(target.x, target.y, target.z);
  };

  // Mouse Handlers
  const handleMouseDown = (e: React.MouseEvent) => {
    // Right click (button 2) or Shift+Click for Panning
    if (e.button === 2 || e.shiftKey) {
        isPanning.current = true;
    } else {
        isDragging.current = true;
    }
    previousMousePosition.current = { x: e.clientX, y: e.clientY };
  };

  const handleMouseMove = (e: React.MouseEvent) => {
    const deltaX = e.clientX - previousMousePosition.current.x;
    const deltaY = e.clientY - previousMousePosition.current.y;
    previousMousePosition.current = { x: e.clientX, y: e.clientY };

    if (isDragging.current) {
        // Orbit
        cameraAngle.current.theta -= deltaX * 0.01;
        cameraAngle.current.phi -= deltaY * 0.01;
        cameraAngle.current.phi = Math.max(0.1, Math.min(Math.PI - 0.1, cameraAngle.current.phi));
        updateCameraPosition();
    } else if (isPanning.current) {
        // Pan
        // Project movement onto camera plane approximate
        const panSpeed = 0.02 * (cameraRadius.current / 10);
        const theta = cameraAngle.current.theta;
        
        // Simple pan logic relative to view direction
        // Right vector approximation
        const rightX = Math.cos(theta);
        const rightZ = -Math.sin(theta);
        
        cameraTarget.current.x -= (rightX * deltaX) * panSpeed;
        cameraTarget.current.z -= (rightZ * deltaX) * panSpeed;
        cameraTarget.current.y += deltaY * panSpeed; // Y is up
        
        updateCameraPosition();
    }
  };

  const handleMouseUp = () => {
    isDragging.current = false;
    isPanning.current = false;
  };

  const handleWheel = (e: React.WheelEvent) => {
    cameraRadius.current += e.deltaY * 0.01;
    cameraRadius.current = Math.max(2, Math.min(30, cameraRadius.current));
    updateCameraPosition();
  };

  return (
    <div className="flex flex-col h-screen w-full bg-slate-50 font-sans text-slate-900">
      
      {/* Header */}
      <div className="h-14 bg-white border-b border-slate-200 flex items-center px-4 justify-between shadow-sm z-10 shrink-0">
        <div className="flex items-center space-x-2">
          <div className="w-8 h-8 bg-indigo-600 rounded-lg flex items-center justify-center text-white font-bold">3D</div>
          <h1 className="font-semibold text-lg text-slate-700">圓錐體截面 (Conic Section)</h1>
        </div>
        
        <div className="flex items-center space-x-4 text-xs sm:text-sm text-slate-500">
          <div className="hidden sm:flex items-center">
             <Move size={14} className="mr-1" /> 右鍵平移視角
          </div>
          <div className="hidden sm:flex items-center">
            <RotateCcw size={14} className="mr-1" /> 左鍵旋轉
          </div>
          <div className="hidden sm:flex items-center">
            <Maximize2 size={14} className="mr-1" /> 滾輪縮放
          </div>
        </div>
      </div>

      <div className="flex flex-1 overflow-hidden relative">
        
        {/* 3D Canvas */}
        <div 
            ref={containerRef} 
            className="w-full h-full cursor-move"
            onMouseDown={handleMouseDown}
            onMouseMove={handleMouseMove}
            onMouseUp={handleMouseUp}
            onMouseLeave={handleMouseUp}
            onWheel={handleWheel}
            onContextMenu={(e) => e.preventDefault()} // Disable context menu for right drag
        >
             {!isThreeLoaded && (
                <div className="flex items-center justify-center h-full w-full text-slate-400">
                    載入 3D 引擎中...
                </div>
             )}
        </div>

        {/* Controls Panel */}
        <div className="absolute top-4 left-4 w-72 bg-white/95 backdrop-blur shadow-lg rounded-xl border border-slate-200 p-4 flex flex-col space-y-4 max-h-[calc(100vh-80px)] overflow-y-auto">
            
            <div className="flex items-center justify-between border-b border-slate-100 pb-2">
                <span className="font-semibold text-slate-700 flex items-center">
                    <Settings size={16} className="mr-2" /> 控制面板
                </span>
                <button 
                  onClick={() => {
                      setHeight(2); 
                      setOffsetX(0);
                      cameraTarget.current = {x:0, y:2.5, z:0};
                      updateCameraPosition();
                  }}
                  className="text-xs text-indigo-600 hover:text-indigo-800"
                >
                    重置
                </button>
            </div>

            {/* Height Slider */}
            <div className="space-y-1">
                <div className="flex justify-between text-sm">
                    <label className="text-slate-600 font-medium">截面高度 (y)</label>
                    <span className="text-indigo-600 font-mono font-bold">{height.toFixed(2)}</span>
                </div>
                <input 
                    type="range" 
                    min="0" 
                    max={CONE_HEIGHT} 
                    step="0.01"
                    value={height}
                    onChange={(e) => setHeight(parseFloat(e.target.value))}
                    className="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-indigo-600"
                />
            </div>

            {/* Horizontal Offset Slider */}
            <div className="space-y-1">
                <div className="flex justify-between text-sm">
                    <label className="text-slate-600 font-medium">水平平移 (x)</label>
                    <span className="text-indigo-600 font-mono font-bold">{offsetX.toFixed(2)}</span>
                </div>
                <input 
                    type="range" 
                    min="-3" 
                    max="3" 
                    step="0.1"
                    value={offsetX}
                    onChange={(e) => setOffsetX(parseFloat(e.target.value))}
                    className="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-teal-600"
                />
                <p className="text-[10px] text-slate-400 leading-tight">
                    *水平平移平面不會改變正圓錐體的圓形截面大小。
                </p>
            </div>

            {/* Radius Display */}
            <div className="space-y-2 pt-2 border-t border-slate-100">
                 <div className="flex justify-between text-sm">
                    <label className="text-slate-600 font-medium">截面半徑 (r)</label>
                    <span className="text-red-500 font-mono font-bold">
                        {(CONE_RADIUS * ((CONE_HEIGHT - height) / CONE_HEIGHT)).toFixed(2)}
                    </span>
                </div>
                <div className="h-1 w-full bg-slate-100 rounded overflow-hidden">
                    <div 
                        className="h-full bg-red-500 transition-all duration-75"
                        style={{ width: `${((CONE_RADIUS * ((CONE_HEIGHT - height) / CONE_HEIGHT)) / CONE_RADIUS) * 100}%` }}
                    />
                </div>
            </div>

            {/* Toggles */}
            <div className="pt-2">
                <label className="flex items-center space-x-2 cursor-pointer hover:bg-slate-50 p-1 rounded transition-colors">
                    <input 
                        type="checkbox" 
                        checked={showPlane} 
                        onChange={(e) => setShowPlane(e.target.checked)}
                        className="rounded text-indigo-600 focus:ring-indigo-500 border-gray-300"
                    />
                    <span className="text-sm text-slate-600">顯示切割平面</span>
                </label>
            </div>

            {/* Info Box */}
            <div className="bg-indigo-50 p-3 rounded-lg text-xs text-indigo-800 flex items-start space-x-2 mt-2">
                <Info size={16} className="mt-0.5 shrink-0" />
                <div>
                    <p className="font-semibold mb-1">截面性質:</p>
                    <p>當平面平行於底面時，截面為<span className="font-bold">圓形</span>。</p>
                    <p className="mt-1 opacity-80">
                        平移切割平面不會影響截面形狀，除非改變切割角度（此工具目前僅演示水平切割）。
                    </p>
                </div>
            </div>

        </div>

      </div>
    </div>
  );
}
